<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>ZEYDOKU üå∏</title>

  <!-- Mobil uyum + PWA hissi -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #ffe6f2, #fff5fb);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      color: #4a2b3c;
      transition: background 0.3s ease, color 0.3s ease;
    }

    .app {
      background: #ffffffdd;
      border-radius: 24px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      padding: 30px 28px 20px;
      max-width: 520px;
      width: 100%;
      position: relative;
      overflow: hidden;
      transition: background 0.3s ease, box-shadow 0.3s ease, transform 0.2s;
    }

    .app::before {
      content: "üå∏";
      position: absolute;
      top: 8px;
      left: 16px;
      font-size: 22px;
    }

    .title {
      text-align: center;
      font-size: 26px;
      font-weight: 800;
      margin-bottom: 2px;
      color: #d14a8c;
      letter-spacing: 1px;
    }

    .top-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 6px;
      margin-bottom: 6px;
    }

    .timer {
      font-size: 13px;
      color: #94637b;
    }

    /* √ústteki buton (Dark) */
    .top-buttons {
      position: absolute;
      top: 8px;
      right: 14px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: flex-end;
    }

    .small-toggle {
      border: none;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
      background: #ffd6ea;
      color: #8a3b6a;
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.05);
      font-weight: 600;
      transition: background 0.2s, color 0.2s, transform 0.1s;
    }

    .small-toggle:hover {
      transform: translateY(-1px);
      background: #ffbedf;
    }

    /* Sudoku konteyneri */
    #sudoku-container {
      display: flex;
      justify-content: center;
      margin-top: 10px;
    }

    /* Melody‚Äôli tahta */
    #sudoku-grid {
      position: relative;
      overflow: hidden;
      transition: box-shadow 0.3s ease, transform 0.3s ease;
    }

    #sudoku-grid::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image: url("mascot.png");   /* dosya: mascot.png */
      background-repeat: no-repeat;
      background-position: center 55%;
      background-size: auto 110%;
      opacity: 0.28;
      pointer-events: none;
      z-index: 0;
      transition: opacity 0.3s ease;
    }

    /* Zorluk se√ßince parlayan efekt */
    @keyframes gridGlow {
      0%   { box-shadow: 0 0 0 rgba(255,153,196,0.0); transform: scale(1);   }
      40%  { box-shadow: 0 0 18px rgba(255,153,196,0.9); transform: scale(1.01); }
      100% { box-shadow: 0 0 0 rgba(255,153,196,0.0); transform: scale(1);   }
    }
    #sudoku-grid.diff-flash {
      animation: gridGlow 0.6s ease-out;
    }

    .cell {
      position: absolute;
      width: 50px;
      height: 50px;
      border: 1px solid #f3c9dd;
      background: transparent;
      cursor: pointer;
      transition: background 0.15s, box-shadow 0.15s, transform 0.15s;
      z-index: 1;
    }

    /* Light mode se√ßili h√ºcre (pembe) */
    body:not(.dark) .cell.selected {
      background: rgba(255, 182, 222, 0.45);
      border-color: #ff8ac7 !important;
      box-shadow: 0 0 8px rgba(255, 140, 200, 0.6);
      transform: scale(1.05);
    }

    .cell.hint-area {
      background: #fff7d6;
    }

    .cell.hint-main {
      background: #ffd9df;
      box-shadow: inset 0 0 0 2px #ff7f7f;
    }

    .cell.thick-right {
      border-right: 2px solid #f099c4;
    }

    .cell.thick-bottom {
      border-bottom: 2px solid #f099c4;
    }

    .main-value {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: 600;
    }

    .main-value.given {
      color: #5a3453;
      font-weight: 700;
    }

    /* Kullanƒ±cƒ±nƒ±n yazdƒ±ƒüƒ± sayƒ±lar: pembe */
    .main-value.user {
      color: #d94b8a;
    }

    .notes {
      position: absolute;
      inset: 3px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      font-size: 9px;
      color: #999;
      pointer-events: none;
    }

    .note {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .controls {
      margin-top: 16px;
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 8px 10px;
      font-size: 13px;
      cursor: pointer;
      font-weight: 500;
      background: #ffd6ea;
      color: #8a3b6a;
      transition: background 0.15s, transform 0.1s, box-shadow 0.15s;
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.05);
    }

    .btn:hover {
      background: #ffbedf;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.05);
    }

    .btn-primary {
      background: #ff9ac4;
      color: #fff;
    }

    .btn-primary:hover {
      background: #ff7fb4;
    }

    .btn-note-on {
      background: #c1f0ff;
      color: #12526a;
    }

    .btn-note-on:hover {
      background: #a3e8ff;
    }

    .numbers-row {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(9, minmax(0, 1fr));
      gap: 6px;
    }

    .number-btn {
      border-radius: 12px;
      padding: 8px 0;
      border: none;
      background: #ffe4f2;
      color: #8a3b6a;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
    }

    .number-btn:hover {
      background: #ffcfe8;
      transform: translateY(-1px);
    }

    .difficulty-row {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .difficulty-label {
      font-size: 13px;
      color: #79435f;
      margin-right: 4px;
    }

    .diff-btn {
      border: none;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
      background: #ffe8f5;
      color: #8a3b6a;
      transition: background 0.15s, transform 0.1s;
    }

    .diff-btn.active {
      background: #ff9ac4;
      color: white;
    }

    .diff-btn:hover {
      background: #ffd0ea;
      transform: translateY(-1px);
    }

    .hint-info {
      margin-top: 6px;
      font-size: 11px;
      text-align: center;
      color: #94637b;
    }

    /* Kalp atan loading overlay */
    #loading-overlay {
      position: absolute;
      inset: 0;
      background: rgba(255, 245, 252, 0.88);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 5;
    }

    #loading-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .heart-loader {
      font-size: 48px;
      animation: heartbeat 0.9s infinite;
    }

    @keyframes heartbeat {
      0%   { transform: scale(1); }
      25%  { transform: scale(1.25); }
      50%  { transform: scale(1); }
      75%  { transform: scale(1.25); }
      100% { transform: scale(1); }
    }

    /* DARK MODE --------------------------------------------------- */
    body.dark {
      background: radial-gradient(circle at top, #2b1224, #05020a 60%);
      color: #fbeaff;
    }

    body.dark .app {
      background: #1c1020f0;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7);
    }

    body.dark .title {
      color: #ff9ad9;
    }

    body.dark .small-toggle {
      background: #3b2438;
      color: #ffd6f3;
    }

    body.dark .small-toggle:hover {
      background: #4a2d46;
    }

    body.dark .btn {
      background: #3b2438;
      color: #ffd6f3;
    }

    body.dark .btn:hover {
      background: #4a2d46;
    }

    body.dark .btn-primary {
      background: #ff5fa8;
      color: #fff;
    }

    body.dark .btn-primary:hover {
      background: #ff3f97;
    }

    body.dark .number-btn {
      background: #3b2438;
      color: #ffd6f3;
    }

    body.dark .number-btn:hover {
      background: #4a2d46;
    }

    body.dark .diff-btn {
      background: #3b2438;
      color: #ffd6f3;
    }

    body.dark .diff-btn.active {
      background: #ff5fa8;
      color: #fff;
    }

    body.dark .difficulty-label,
    body.dark .hint-info,
    body.dark .timer {
      color: #f1c7ec;
    }

    body.dark .cell {
      border-color: #ff9ad9;
    }

    body.dark .main-value.given {
      color: #ffe6ff;
    }

    body.dark .main-value.user {
      color: #ffb3dd;
    }

    /* Dark modda se√ßili h√ºcre daha koyu pembe */
    body.dark .cell.selected {
      background: rgba(255, 80, 150, 0.48);
      box-shadow: 0 0 18px rgba(255, 110, 185, 0.85);
      border-color: #ff5ab6 !important;
      transform: scale(1.05);
    }

    body.dark #sudoku-grid::before {
      opacity: 0.35;
    }

    body.dark #loading-overlay {
      background: rgba(10, 3, 18, 0.85);
    }

    /* Mobil ayarlar */
    @media (max-width: 600px) {
      .app {
        transform: scale(0.95);
        padding: 22px 16px 16px;
      }
      .btn {
        padding: 10px 12px;
        font-size: 14px;
      }
      .number-btn {
        padding: 10px 0;
        font-size: 16px;
      }
      .small-toggle {
        padding: 4px 8px;
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="title">üíóZEYDOKUüíó</div>

    <div class="top-buttons">
      <button id="theme-toggle" class="small-toggle">üåô Dark</button>
    </div>

    <div class="top-bar">
      <div id="timer" class="timer">‚è±Ô∏è 00:00</div>
    </div>

    <div id="sudoku-container">
      <div id="sudoku-grid"></div>
    </div>

    <div class="controls">
      <button id="new-game" class="btn btn-primary">Yeni Oyun</button>
      <button id="check" class="btn">Kontrol Et</button>
      <button id="show-solution" class="btn">√á√∂z√ºm√º G√∂ster</button>
      <button id="hint" class="btn">ƒ∞pucu</button>

      <button id="note-mode" class="btn">Not Modu: Kapalƒ±</button>
      <button id="clear-cell" class="btn">Sil</button>
      <div class="hint-info" style="grid-column: span 2;">
        <!-- burayƒ± bo≈ü bƒ±rak dedin -->
      </div>
    </div>

    <div class="numbers-row" id="numbers-row"></div>

    <div class="difficulty-row">
      <span class="difficulty-label">Zorluk:</span>
      <button class="diff-btn" data-diff="kolay">Kolay</button>
      <button class="diff-btn active" data-diff="orta">Orta</button>
      <button class="diff-btn" data-diff="zor">Zor</button>
      <button class="diff-btn" data-diff="cok_zor">√áok Zor</button>
    </div>

    <!-- Kalp atan loading -->
    <div id="loading-overlay">
      <div class="heart-loader">üíó</div>
    </div>
  </div>

  <script>
    const N = 9;
    const CELL_SIZE = 50;
    const MARGIN = 10;

    const STORAGE_KEY = "zeydoku_state_v1";

    let puzzle = null;
    let solution = null;
    let userGrid = null;
    let candidates = null;
    let selectedCell = null;
    let noteMode = false;
    let difficulty = "orta";
    let hintCells = [];
    let hintMain = null;

    let loadingOverlay = null;
    let gridEl = null;
    let themeToggle = null;
    let timerEl = null;

    let timerInterval = null;
    let elapsedSeconds = 0;

    function findEmpty(grid) {
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          if (grid[r][c] === 0) return [r, c];
        }
      }
      return null;
    }

    function isValid(grid, row, col, num) {
      for (let c = 0; c < N; c++) {
        if (grid[row][c] === num) return false;
      }
      for (let r = 0; r < N; r++) {
        if (grid[r][col] === num) return false;
      }
      const br = Math.floor(row / 3) * 3;
      const bc = Math.floor(col / 3) * 3;
      for (let r = br; r < br + 3; r++) {
        for (let c = bc; c < bc + 3; c++) {
          if (grid[r][c] === num) return false;
        }
      }
      return true;
    }

    function fillGrid(grid) {
      const empty = findEmpty(grid);
      if (!empty) return true;
      const [r, c] = empty;
      const nums = [1,2,3,4,5,6,7,8,9];
      shuffle(nums);
      for (const num of nums) {
        if (isValid(grid, r, c, num)) {
          grid[r][c] = num;
          if (fillGrid(grid)) return true;
          grid[r][c] = 0;
        }
      }
      return false;
    }

    function countSolutions(grid, limit = 2) {
      let solutions = 0;
      function backtrack() {
        if (solutions >= limit) return;
        const empty = findEmpty(grid);
        if (!empty) {
          solutions += 1;
          return;
        }
        const [r, c] = empty;
        for (let num = 1; num <= 9; num++) {
          if (isValid(grid, r, c, num)) {
            grid[r][c] = num;
            backtrack();
            grid[r][c] = 0;
            if (solutions >= limit) return;
          }
        }
      }
      backtrack();
      return solutions;
    }

    function generatePuzzle(diff = "orta") {
      const grid = Array.from({length: N}, () => Array(N).fill(0));
      fillGrid(grid);
      const solution = grid.map(row => row.slice());

      const clueTargets = {
        "kolay": 40,
        "orta": 32,
        "zor": 26,
        "cok_zor": 22
      };
      const minClues = clueTargets[diff] ?? 32;

      let clues = N * N;
      const cells = [];
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) cells.push([r, c]);
      }
      shuffle(cells);

      for (const [r, c] of cells) {
        if (clues <= minClues) break;
        const backup = grid[r][c];
        grid[r][c] = 0;
        const temp = grid.map(row => row.slice());
        if (countSolutions(temp, 2) !== 1) {
          grid[r][c] = backup;
        } else {
          clues -= 1;
        }
      }

      return { puzzle: grid, solution };
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function showLoading() {
      if (loadingOverlay) loadingOverlay.classList.add("visible");
    }
    function hideLoading() {
      if (loadingOverlay) loadingOverlay.classList.remove("visible");
    }

    function updateTimerDisplay() {
      if (!timerEl) return;
      const m = Math.floor(elapsedSeconds / 60);
      const s = elapsedSeconds % 60;
      const mm = String(m).padStart(2, "0");
      const ss = String(s).padStart(2, "0");
      timerEl.textContent = `‚è±Ô∏è ${mm}:${ss}`;
    }

    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        elapsedSeconds++;
        updateTimerDisplay();
        saveState();
      }, 1000);
    }

    function stopTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function flashDifficulty() {
      if (!gridEl) return;
      gridEl.classList.remove("diff-flash");
      void gridEl.offsetWidth;
      gridEl.classList.add("diff-flash");
    }

    function serializeCandidates(cand) {
      return cand.map(row => row.map(set => Array.from(set)));
    }

    function deserializeCandidates(data) {
      return data.map(row => row.map(arr => new Set(arr)));
    }

    function saveState() {
      if (!puzzle || !solution || !userGrid || !candidates) return;
      const state = {
        puzzle,
        solution,
        userGrid,
        candidates: serializeCandidates(candidates),
        difficulty,
        isDark: document.body.classList.contains("dark"),
        elapsedSeconds
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        console.warn("State kaydedilemedi:", e);
      }
    }

    function loadState() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        newGame(true);
        return;
      }
      try {
        const state = JSON.parse(raw);
        if (!state || !state.puzzle || !state.solution || !state.userGrid) {
          newGame(true);
          return;
        }
        puzzle = state.puzzle;
        solution = state.solution;
        userGrid = state.userGrid;
        candidates = deserializeCandidates(state.candidates || []);
        difficulty = state.difficulty || "orta";
        elapsedSeconds = state.elapsedSeconds || 0;

        if (state.isDark) {
          document.body.classList.add("dark");
          if (themeToggle) themeToggle.textContent = "‚òÄÔ∏è Light";
        } else {
          document.body.classList.remove("dark");
          if (themeToggle) themeToggle.textContent = "üåô Dark";
        }

        document.querySelectorAll(".diff-btn").forEach(btn => {
          btn.classList.remove("active");
          if (btn.dataset.diff === difficulty) {
            btn.classList.add("active");
          }
        });

        selectedCell = null;
        hintCells = [];
        hintMain = null;
        renderGrid();
        updateTimerDisplay();
        startTimer();
      } catch (e) {
        console.warn("State okunamadƒ±, yeni oyun ba≈ülatƒ±lƒ±yor:", e);
        newGame(true);
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      gridEl = document.getElementById("sudoku-grid");
      loadingOverlay = document.getElementById("loading-overlay");
      themeToggle = document.getElementById("theme-toggle");
      timerEl = document.getElementById("timer");

      gridEl.style.width = (CELL_SIZE * N + 2 * MARGIN) + "px";
      gridEl.style.height = (CELL_SIZE * N + 2 * MARGIN) + "px";

      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.style.left = (MARGIN + c * CELL_SIZE) + "px";
          cell.style.top = (MARGIN + r * CELL_SIZE) + "px";
          cell.dataset.row = r;
          cell.dataset.col = c;

          if (c === 2 || c === 5) cell.classList.add("thick-right");
          if (r === 2 || r === 5) cell.classList.add("thick-bottom");

          cell.addEventListener("click", () => onCellClick(r, c));
          gridEl.appendChild(cell);
        }
      }

      const numsRow = document.getElementById("numbers-row");
      for (let i = 1; i <= 9; i++) {
        const btn = document.createElement("button");
        btn.textContent = i;
        btn.className = "number-btn";
        btn.addEventListener("click", () => numberPressed(i));
        numsRow.appendChild(btn);
      }

      document.getElementById("new-game").addEventListener("click", () => {
        flashDifficulty();
        newGame(false);
      });
      document.getElementById("check").addEventListener("click", checkSolution);
      document.getElementById("show-solution").addEventListener("click", showSolution);
      document.getElementById("hint").addEventListener("click", giveHint);
      document.getElementById("clear-cell").addEventListener("click", clearCell);

      const noteBtn = document.getElementById("note-mode");
      noteBtn.addEventListener("click", () => {
        noteMode = !noteMode;
        noteBtn.textContent = "Not Modu: " + (noteMode ? "A√ßƒ±k" : "Kapalƒ±");
        if (noteMode) noteBtn.classList.add("btn-note-on");
        else noteBtn.classList.remove("btn-note-on");
      });

      document.querySelectorAll(".diff-btn").forEach(btn => {
        btn.addEventListener("click", () => {
          document.querySelectorAll(".diff-btn").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          difficulty = btn.dataset.diff;
          flashDifficulty();
          newGame(false);
        });
      });

      themeToggle.addEventListener("click", () => {
        document.body.classList.toggle("dark");
        if (document.body.classList.contains("dark")) {
          themeToggle.textContent = "‚òÄÔ∏è Light";
        } else {
          themeToggle.textContent = "üåô Dark";
        }
        saveState();
      });

      loadState();
    });

    function newGame(isInitial) {
      showLoading();
      stopTimer();
      elapsedSeconds = 0;
      updateTimerDisplay();

      setTimeout(() => {
        const { puzzle: p, solution: s } = generatePuzzle(difficulty);
        puzzle = p;
        solution = s;
        userGrid = puzzle.map(row => row.slice());
        candidates = Array.from({length: N}, () => Array.from({length: N}, () => new Set()));
        selectedCell = null;
        hintCells = [];
        hintMain = null;
        renderGrid();
        hideLoading();
        startTimer();
        saveState();
      }, isInitial ? 0 : 80);
    }

    function renderGrid() {
      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        const r = Number(cell.dataset.row);
        const c = Number(cell.dataset.col);
        cell.classList.remove("selected", "hint-area", "hint-main");

        if (selectedCell && selectedCell.row === r && selectedCell.col === c) {
          cell.classList.add("selected");
        }
        if (hintMain && hintMain.row === r && hintMain.col === c) {
          cell.classList.add("hint-main");
        } else if (hintCells.some(pos => pos.row === r && pos.col === c)) {
          cell.classList.add("hint-area");
        }

        cell.innerHTML = "";
        const val = puzzle[r][c];
        const uval = userGrid[r][c];

        if (val !== 0) {
          const mv = document.createElement("div");
          mv.className = "main-value given";
          mv.textContent = val;
          cell.appendChild(mv);
        } else if (uval !== 0) {
          const mv = document.createElement("div");
          mv.className = "main-value user";
          mv.textContent = uval;
          cell.appendChild(mv);
        } else if (candidates && candidates[r][c].size > 0) {
          const notesDiv = document.createElement("div");
          notesDiv.className = "notes";
          for (let d = 1; d <= 9; d++) {
            const span = document.createElement("div");
            span.className = "note";
            if (candidates[r][c].has(d)) span.textContent = d;
            notesDiv.appendChild(span);
          }
          cell.appendChild(notesDiv);
        }
      });
    }

    function onCellClick(r, c) {
      selectedCell = {row: r, col: c};
      hintCells = [];
      hintMain = null;
      renderGrid();
    }

    function clearCell() {
      if (!selectedCell) return;
      const {row, col} = selectedCell;
      if (puzzle[row][col] !== 0) return;

      if (noteMode) {
        candidates[row][col].clear();
      } else {
        userGrid[row][col] = 0;
      }
      hintCells = [];
      hintMain = null;
      renderGrid();
      saveState();
    }

    function numberPressed(d) {
      if (!selectedCell) return;
      const {row, col} = selectedCell;
      if (puzzle[row][col] !== 0) return;

      if (noteMode) {
        if (userGrid[row][col] !== 0) return;
        if (candidates[row][col].has(d)) {
          candidates[row][col].delete(d);
        } else {
          candidates[row][col].add(d);
        }
      } else {
        userGrid[row][col] = d;
        candidates[row][col].clear();
      }

      hintCells = [];
      hintMain = null;
      renderGrid();
      saveState();
    }

    function checkSolution() {
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          if (userGrid[r][c] !== solution[r][c]) {
            alert("√á√∂z√ºm doƒüru deƒüil, biraz daha dene üôÇ");
            return;
          }
        }
      }
      stopTimer();
      const m = Math.floor(elapsedSeconds / 60);
      const s = elapsedSeconds % 60;
      const mm = String(m).padStart(2, "0");
      const ss = String(s).padStart(2, "0");
      alert(`Tebrikler! Sudokuyu √ß√∂zd√ºn üéâ\nS√ºren: ${mm}:${ss}`);
      saveState();
    }

    function showSolution() {
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          userGrid[r][c] = solution[r][c];
          candidates[r][c].clear();
        }
      }
      stopTimer();
      hintCells = [];
      hintMain = null;
      renderGrid();
      saveState();
    }

    function computeLogicCandidates() {
      const grid = userGrid.map(row => row.slice());
      const cands = Array.from({length: N}, () => Array.from({length: N}, () => new Set()));
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          if (grid[r][c] === 0) {
            for (let d = 1; d <= 9; d++) {
              if (isValid(grid, r, c, d)) cands[r][c].add(d);
            }
          }
        }
      }
      return cands;
    }

    function notesComment(r, c, d, scopeType) {
      let msg = "";
      const userNotes = candidates[r][c];

      if (userNotes.size > 0) {
        if (userNotes.has(d) && userNotes.size > 1) {
          msg += `\nNotlarƒ±nda ${d} zaten var, diƒüer adaylarƒ±nƒ± azaltmayƒ± d√º≈ü√ºnebilirsin.`;
        } else if (userNotes.has(d) && userNotes.size === 1) {
          msg += `\nNotlarƒ±nla zaten ${d}‚Äôyi se√ßmi≈üsin, artƒ±k bu kareyi doldurabilirsin.`;
        } else if (!userNotes.has(d)) {
          msg += `\nNot tutuyorsan, bu kareye ${d} adayƒ±nƒ± ekleyebilirsin.`;
        }
      } else {
        msg += `\nBu karede hi√ß notun yoksa, ${d}‚Äôyi g√º√ßl√º bir aday olarak d√º≈ü√ºnebilirsin.`;
      }

      if (scopeType === "row") {
        const others = [];
        for (let cc = 0; cc < N; cc++) {
          if (candidates[r][cc].has(d) && cc !== c) others.push([r, cc]);
        }
        if (others.length > 0) {
          msg += `\nBu satƒ±rdaki diƒüer karelere yazdƒ±ƒüƒ±n ${d} notlarƒ±nƒ± silebilirsin.`;
        }
      } else if (scopeType === "col") {
        const others = [];
        for (let rr = 0; rr < N; rr++) {
          if (candidates[rr][c].has(d) && rr !== r) others.push([rr, c]);
        }
        if (others.length > 0) {
          msg += `\nBu s√ºtundaki diƒüer karelerdeki ${d} notlarƒ±nƒ± da temizleyebilirsin.`;
        }
      } else if (scopeType === "box") {
        const br = Math.floor(r / 3) * 3;
        const bc = Math.floor(c / 3) * 3;
        const others = [];
        for (let rr = br; rr < br + 3; rr++) {
          for (let cc = bc; cc < br + 3; cc++) {
            if (candidates[rr][cc].has(d) && (rr !== r || cc !== c)) {
              others.push([rr, cc]);
            }
          }
        }
        if (others.length > 0) {
          msg += `\nBu kutudaki diƒüer h√ºcrelere yazdƒ±ƒüƒ±n ${d} notlarƒ±nƒ± silebilirsin.`;
        }
      } else if (scopeType === "single") {
        if (userNotes.size > 1 || userNotes.has(d)) {
          msg += `\nBurada sadece ${d} ge√ßerli olduƒüundan, diƒüer t√ºm notlarƒ±nƒ± g√ºvenle silebilirsin.`;
        }
      }

      return msg;
    }

    function giveHint() {
      const cands = computeLogicCandidates();

      for (let r = 0; r < N; r++) {
        for (let d = 1; d <= 9; d++) {
          const cells = [];
          for (let c = 0; c < N; c++) {
            if (cands[r][c].has(d)) cells.push({row: r, col: c});
          }
          if (cells.length === 1) {
            const {row, col} = cells[0];
            hintMain = {row, col};
            hintCells = [];
            for (let cc = 0; cc < N; cc++) hintCells.push({row: r, col: cc});
            selectedCell = {row, col};
            renderGrid();
            const extra = notesComment(row, col, d, "row");
            alert(`${r+1}. satƒ±ra odaklan.\nSayƒ± ${d} bu satƒ±rda sadece se√ßili kareye sƒ±ƒüƒ±yor.` + extra);
            saveState();
            return;
          }
        }
      }

      for (let c = 0; c < N; c++) {
        for (let d = 1; d <= 9; d++) {
          const cells = [];
          for (let r = 0; r < N; r++) {
            if (cands[r][c].has(d)) cells.push({row: r, col: c});
          }
          if (cells.length === 1) {
            const {row, col} = cells[0];
            hintMain = {row, col};
            hintCells = [];
            for (let rr = 0; rr < N; rr++) hintCells.push({row: rr, col: c});
            selectedCell = {row, col};
            renderGrid();
            const extra = notesComment(row, col, d, "col");
            alert(`${c+1}. s√ºtuna bak.\nSayƒ± ${d} bu s√ºtunda sadece se√ßili h√ºcrede m√ºmk√ºn.` + extra);
            saveState();
            return;
          }
        }
      }

      for (let br = 0; br < N; br += 3) {
        for (let bc = 0; bc < N; bc += 3) {
          for (let d = 1; d <= 9; d++) {
            const cells = [];
            for (let r = br; r < br + 3; r++) {
              for (let c = bc; c < bc + 3; c++) {
                if (cands[r][c].has(d)) cells.push({row: r, col: c});
              }
            }
            if (cells.length === 1) {
              const {row, col} = cells[0];
              hintMain = {row, col};
              hintCells = [];
              for (let r = br; r < br + 3; r++) {
                for (let c = bc; c < bc + 3; c++) {
                  hintCells.push({row: r, col: c});
                }
              }
              selectedCell = {row, col};
              renderGrid();
              const extra = notesComment(row, col, d, "box");
              alert(`Se√ßili h√ºcrenin bulunduƒüu 3√ó3 kutuya bak.\nSayƒ± ${d} bu kutuda sadece bu kareye sƒ±ƒüƒ±yor.` + extra);
              saveState();
              return;
            }
          }
        }
      }

      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          if (userGrid[r][c] === 0 && cands[r][c].size === 1) {
            const d = [...cands[r][c]][0];
            hintMain = {row: r, col: c};
            hintCells = [];
            selectedCell = {row: r, col: c};
            renderGrid();
            const extra = notesComment(r, c, d, "single");
            alert(`Se√ßili kareye bak.\nSudoku kurallarƒ±na g√∂re burada sadece ${d} m√ºmk√ºn.` + extra);
            saveState();
            return;
          }
        }
      }

      alert("Basit mantƒ±kla bulunabilecek yeni bir hamle kalmadƒ±.\nBelki daha ileri teknikler gerekir üôÇ");
    }
  </script>
</body>
</html>
