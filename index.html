<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>ZEYDOKU üå∏</title>

  <!-- Mobil uyum -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" href="apple-touch-icon.png">

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #ffe6f2, #fff5fb);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      color: #4a2b3c;
      transition: background 0.3s ease, color 0.3s ease;
    }

    .app {
      background: #ffffffdd;
      border-radius: 24px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.12);
      padding: 20px 18px 18px;
      width: 100%;
      max-width: 480px;
      margin: 10px;
      position: relative;
      overflow: hidden;
      transition: background 0.3s ease, box-shadow 0.3s ease;
    }

    .app::before {
      content: "üå∏";
      position: absolute;
      top: 6px;
      left: 12px;
      font-size: 20px;
    }

    /* Ba≈ülƒ±k satƒ±rƒ± ortalƒ± */
    .top-row {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 4px;
    }
    .top-row > :first-child,
    .top-right {
      width: 70px;
    }
    .top-right {
      display: flex;
      justify-content: flex-end;
      gap: 4px;
    }

    .title {
      text-align: center;
      font-size: 26px;
      font-weight: 800;
      margin-bottom: 2px;
      color: #d14a8c;
      letter-spacing: 1px;
    }

    .timer {
      font-size: 13px;
      text-align: center;
      color: #94637b;
      margin-top: 2px;
    }

    .mistake-info {
      font-size: 12px;
      text-align: center;
      margin-top: 2px;
      color: #b1526e;
    }

    .small-toggle {
      border: none;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
      background: #ffd6ea;
      color: #8a3b6a;
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.05);
      font-weight: 600;
      transition: background 0.2s, color 0.2s, transform 0.1s;
    }
    .small-toggle:hover {
      transform: translateY(-1px);
      background: #ffbedf;
    }

    #sudoku-container {
      display: flex;
      justify-content: center;
      margin-top: 6px;
    }

    #sudoku-grid {
      position: relative;
      width: 100%;
      max-width: 360px;
      aspect-ratio: 1 / 1;
      margin: 0 auto;
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr);
      place-items: stretch;
      overflow: hidden;
    }

    #sudoku-grid::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image: url("mascot.png"); /* Melody PNG */
      background-repeat: no-repeat;
      background-position: center 55%;
      background-size: auto 110%;
      opacity: 0.28;
      pointer-events: none;
      z-index: 0;
    }

    @keyframes gridGlow {
      0%   { box-shadow: 0 0 0 rgba(255,153,196,0.0); transform: scale(1); }
      40%  { box-shadow: 0 0 18px rgba(255,153,196,0.9); transform: scale(1.01); }
      100% { box-shadow: 0 0 0 rgba(255,153,196,0.0); transform: scale(1); }
    }
    #sudoku-grid.diff-flash {
      animation: gridGlow 0.6s ease-out;
    }

    .cell {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      cursor: pointer;
      transition: background 0.15s, box-shadow 0.15s, transform 0.15s;
      z-index: 1;
      box-shadow: inset 0 0 0 1px #f7b9dd; /* ince ama belirgin */
    }

    .cell.thick-right {
      box-shadow:
        inset 0 0 0 1px #f7b9dd,
        inset -3px 0 0 0 #ff4fa8;
    }
    .cell.thick-bottom {
      box-shadow:
        inset 0 0 0 1px #f7b9dd,
        inset 0 -3px 0 0 #ff4fa8;
    }
    .cell.thick-right.thick-bottom {
      box-shadow:
        inset 0 0 0 1px #f7b9dd,
        inset -3px 0 0 0 #ff4fa8,
        inset 0 -3px 0 0 #ff4fa8;
    }

    body:not(.dark) .cell.selected {
      background: rgba(255, 182, 222, 0.45);
      box-shadow: inset 0 0 0 1px #ff8ac7, 0 0 8px rgba(255, 140, 200, 0.6);
      transform: scale(1.02);
    }

    .cell.hint-area {
      background: #fff7d6;
    }
    .cell.hint-main {
      background: #ffd9df;
      box-shadow: inset 0 0 0 2px #ff7f7f;
    }
/* Dark modda ipucu √ßok parlamasƒ±n ama belli olsun */
body.dark .cell.hint-area {
  background: rgba(255, 255, 200, 0.12);
}

body.dark .cell.hint-main {
  background: rgba(255, 160, 220, 0.28);
  box-shadow: inset 0 0 0 2px #ff9ad9;
}


    .main-value {
      position: relative;
      font-size: clamp(18px, 2.8vw, 22px);
      font-weight: 600;
    }

    .main-value.given {
      color: #5a3453;
      font-weight: 700;
    }

    .main-value.user {
      color: #ff6fb3;
    }

    .notes {
      position: absolute;
      inset: 3px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      font-size: 8px;
      color: #999;
      pointer-events: none;
    }
    .note {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .controls {
      margin-top: 14px;
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 8px 10px;
      font-size: 13px;
      cursor: pointer;
      font-weight: 500;
      background: #ffd6ea;
      color: #8a3b6a;
      transition: background 0.15s, transform 0.1s, box-shadow 0.15s;
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.05);
    }
    .btn:hover {
      background: #ffbedf;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
    }
    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.05);
    }
    .btn-primary {
      background: #ff9ac4;
      color: #fff;
    }
    .btn-primary:hover {
      background: #ff7fb4;
    }

    /* Not modu A√áIKKEN buton rengi */
.btn-note-on {
  background: #f4c8ff;      /* lila-pembe */
  color: #5a245f;           /* koyu mor yazƒ± */
}
.btn-note-on:hover {
  background: #f0b0ff;      /* hover'da bir tƒ±k koyu */
}


    .numbers-row {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(9, minmax(0, 1fr));
      gap: 6px;
    }
    .number-btn {
      border-radius: 12px;
      padding: 8px 0;
      border: none;
      background: #ffe4f2;
      color: #8a3b6a;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
    }
    .number-btn:hover {
      background: #ffcfe8;
      transform: translateY(-1px);
    }

    .difficulty-row {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    .difficulty-label {
      font-size: 13px;
      color: #79435f;
      margin-right: 4px;
    }
    .diff-btn {
      border: none;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
      background: #ffe8f5;
      color: #8a3b6a;
      transition: background 0.15s, transform 0.1s;
    }
    .diff-btn.active {
      background: #ff9ac4;
      color: white;
    }
    .diff-btn:hover {
      background: #ffd0ea;
      transform: translateY(-1px);
    }

    .hint-info {
      margin-top: 6px;
      font-size: 11px;
      text-align: center;
      color: #94637b;
    }

    #loading-overlay {
      position: absolute;
      inset: 0;
      background: rgba(255, 245, 252, 0.88);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 5;
    }
    #loading-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }
    .heart-loader {
      font-size: 44px;
      animation: heartbeat 0.9s infinite;
    }
    @keyframes heartbeat {
      0%   { transform: scale(1); }
      25%  { transform: scale(1.25); }
      50%  { transform: scale(1); }
      75%  { transform: scale(1.25); }
      100% { transform: scale(1); }
    }

    /* Aynƒ± sayƒ± vurgusu */
    .cell.same-number {
      background: rgba(255, 105, 180, 0.22);
      box-shadow: 0 0 10px rgba(255, 105, 180, 0.6);
    }
    body.dark .cell.same-number {
      background: rgba(255, 105, 180, 0.32);
      box-shadow: 0 0 14px rgba(255, 105, 180, 0.85);
    }

    /* Hatalƒ± giri≈ü efekti */
    .cell.invalid {
      background: rgba(255, 60, 90, 0.35) !important;
      box-shadow: 0 0 14px rgba(255, 60, 90, 0.9) !important;
      animation: shake 0.15s ease-in-out 2;
    }
    .cell.invalid .main-value {
      color: #ff1f5a !important;
      font-weight: 800;
    }
    @keyframes shake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-2px); }
      50% { transform: translateX(2px); }
      75% { transform: translateX(-2px); }
      100% { transform: translateX(0); }
    }

    /* DARK MODE --------------------------------------------------- */

    body.dark {
      background: radial-gradient(circle at top, #2b1224, #05020a 60%);
      color: #fbeaff;
    }
    body.dark .app {
      background: #1c1020f0;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7);
    }
    body.dark .title {
      color: #ff9ad9;
    }
    body.dark .small-toggle {
      background: #3b2438;
      color: #ffd6f3;
    }
    body.dark .small-toggle:hover {
      background: #4a2d46;
    }

    body.dark .btn {
      background: #3b2438;
      color: #ffd6f3;
    }
    body.dark .btn:hover {
      background: #4a2d46;
    }
    body.dark .btn-primary {
      background: #ff5fa8;
      color: #fff;
    }
    body.dark .btn-primary:hover {
      background: #ff3f97;
    }

    body.dark .number-btn {
      background: #3b2438;
      color: #ffd6f3;
    }
    body.dark .number-btn:hover {
      background: #4a2d46;
    }

    body.dark .diff-btn {
      background: #3b2438;
      color: #ffd6f3;
    }
    body.dark .diff-btn.active {
      background: #ff5fa8;
      color: #fff;
    }

    body.dark .difficulty-label,
    body.dark .hint-info,
    body.dark .timer,
    body.dark .mistake-info {
      color: #f1c7ec;
    }

    body.dark .cell {
      box-shadow: inset 0 0 0 0.5px rgba(255, 179, 227, 0.8);
    }
    body.dark .cell.thick-right {
      box-shadow:
        inset 0 0 0 0.5px rgba(255, 179, 227, 0.8),
        inset -4px 0 0 0 #ff2c96;
    }
    body.dark .cell.thick-bottom {
      box-shadow:
        inset 0 0 0 0.5px rgba(255, 179, 227, 0.8),
        inset 0 -4px 0 0 #ff2c96;
    }
    body.dark .cell.thick-right.thick-bottom {
      box-shadow:
        inset 0 0 0 0.5px rgba(255, 179, 227, 0.8),
        inset -4px 0 0 0 #ff2c96,
        inset 0 -4px 0 0 #ff2c96;
    }

    body.dark .main-value.given {
      color: #ffe6ff;
    }

    body.dark .main-value.user {
      color: #ff8ccd;
      font-weight: 700;
      text-shadow: 0 0 5px rgba(255, 140, 205, 0.55);
    }

    body.dark .cell.selected {
      background: rgba(255, 80, 150, 0.45);
      box-shadow:
        inset 0 0 0 1px #ff5ab6,
        0 0 18px rgba(255, 110, 185, 0.85);
      transform: scale(1.02);
    }

    body.dark #sudoku-grid::before {
      opacity: 0.36;
    }
    body.dark #loading-overlay {
      background: rgba(10, 3, 18, 0.85);
    }

    @media (max-width: 600px) {
      .app {
        padding: 18px 14px 16px;
        border-radius: 20px;
      }
      .btn {
        padding: 9px 10px;
        font-size: 13px;
      }
      .number-btn {
        padding: 10px 0;
        font-size: 15px;
      }
      .title {
        font-size: 24px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="top-row">
      <div></div>
      <div class="title">üíóZEYDOKUüíó</div>
      <div class="top-right">
        <button id="theme-toggle" class="small-toggle">üåô Dark</button>
      </div>
    </div>
    <div class="timer" id="timer">‚è±Ô∏è 00:00</div>
    <div class="mistake-info" id="mistake-info">Hata: 0/5</div>

    <div id="sudoku-container">
      <div id="sudoku-grid"></div>
    </div>

    <div class="controls">
      <button id="new-game" class="btn btn-primary">Yeni Oyun</button>
      <button id="check" class="btn">Kontrol Et</button>
      <button id="show-solution" class="btn">√á√∂z√ºm√º G√∂ster</button>
      <button id="hint" class="btn">ƒ∞pucu</button>

      <button id="note-mode" class="btn">Not Modu: Kapalƒ±</button>
      <button id="clear-cell" class="btn">Sil</button>
      <div class="hint-info" style="grid-column: span 2;"></div>
    </div>

    <div class="numbers-row" id="numbers-row"></div>

    <div class="difficulty-row">
      <span class="difficulty-label">Zorluk:</span>
      <button class="diff-btn" data-diff="kolay">Kolay</button>
      <button class="diff-btn active" data-diff="orta">Orta</button>
      <button class="diff-btn" data-diff="zor">Zor</button>
      <button class="diff-btn" data-diff="cok_zor">√áok Zor</button>
    </div>

    <div id="loading-overlay">
      <div class="heart-loader">üíó</div>
    </div>
  </div>

  <script>
    const N = 9;
    const STORAGE_KEY = "zeydoku_state_v3";
    const MAX_MISTAKES = 5;

    let puzzle = null;
    let solution = null;
    let userGrid = null;
    let candidates = null;
    let fixedByUser = null;   // doƒüru doldurulan ve kilitlenen h√ºcreler
    let selectedCell = null;
    let selectedValue = null;
    let noteMode = false;
    let difficulty = "orta";
    let hintCells = [];
    let hintMain = null;

    let loadingOverlay = null;
    let gridEl = null;
    let themeToggle = null;
    let timerEl = null;
    let mistakeInfoEl = null;

    let timerInterval = null;
    let elapsedSeconds = 0;
    let mistakeCount = 0;

    function findEmpty(grid) {
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          if (grid[r][c] === 0) return [r, c];
        }
      }
      return null;
    }

    function isValid(grid, row, col, num) {
      for (let c = 0; c < N; c++) {
        if (grid[row][c] === num) return false;
      }
      for (let r = 0; r < N; r++) {
        if (grid[r][col] === num) return false;
      }
      const br = Math.floor(row / 3) * 3;
      const bc = Math.floor(col / 3) * 3;
      for (let r = br; r < br + 3; r++) {
        for (let c = bc; c < bc + 3; c++) {
          if (grid[r][c] === num) return false;
        }
      }
      return true;
    }

    function fillGrid(grid) {
      const empty = findEmpty(grid);
      if (!empty) return true;
      const [r, c] = empty;
      const nums = [1,2,3,4,5,6,7,8,9];
      shuffle(nums);
      for (const num of nums) {
        if (isValid(grid, r, c, num)) {
          grid[r][c] = num;
          if (fillGrid(grid)) return true;
          grid[r][c] = 0;
        }
      }
      return false;
    }

    function countSolutions(grid, limit = 2) {
      let solutions = 0;
      function backtrack() {
        if (solutions >= limit) return;
        const empty = findEmpty(grid);
        if (!empty) {
          solutions += 1;
          return;
        }
        const [r, c] = empty;
        for (let num = 1; num <= 9; num++) {
          if (isValid(grid, r, c, num)) {
            grid[r][c] = num;
            backtrack();
            grid[r][c] = 0;
            if (solutions >= limit) return;
          }
        }
      }
      backtrack();
      return solutions;
    }

// Bir h√ºcreye d sayƒ±sƒ±nƒ± yerle≈ütirdikten sonra,
// aynƒ± satƒ±r, s√ºtun ve 3x3 kutudaki notlardan d'yi sil
function updateNotesAfterNumber(row, col, d) {
  if (!candidates) return;

  // satƒ±r
  for (let c = 0; c < N; c++) {
    if (c === col) continue;
    candidates[row][c].delete(d);
  }

  // s√ºtun
  for (let r = 0; r < N; r++) {
    if (r === row) continue;
    candidates[r][col].delete(d);
  }

  // 3x3 kutu
  const br = Math.floor(row / 3) * 3;
  const bc = Math.floor(col / 3) * 3;
  for (let r = br; r < br + 3; r++) {
    for (let c = bc; c < bc + 3; c++) {
      if (r === row && c === col) continue;
      candidates[r][c].delete(d);
    }
  }
}


    function generatePuzzle(diff = "orta") {
      const grid = Array.from({length: N}, () => Array(N).fill(0));
      fillGrid(grid);
      const solution = grid.map(row => row.slice());

      const clueTargets = {
        "kolay": 40,
        "orta": 32,
        "zor": 26,
        "cok_zor": 22
      };
      const minClues = clueTargets[diff] ?? 32;

      let clues = N * N;
      const cells = [];
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) cells.push([r, c]);
      }
      shuffle(cells);

      for (const [r, c] of cells) {
        if (clues <= minClues) break;
        const backup = grid[r][c];
        grid[r][c] = 0;
        const temp = grid.map(row => row.slice());
        if (countSolutions(temp, 2) !== 1) {
          grid[r][c] = backup;
        } else {
          clues -= 1;
        }
      }

      return { puzzle: grid, solution };
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function showLoading() {
      if (loadingOverlay) loadingOverlay.classList.add("visible");
    }
    function hideLoading() {
      if (loadingOverlay) loadingOverlay.classList.remove("visible");
    }

    function updateTimerDisplay() {
      if (!timerEl) return;
      const m = Math.floor(elapsedSeconds / 60);
      const s = elapsedSeconds % 60;
      const mm = String(m).padStart(2, "0");
      const ss = String(s).padStart(2, "0");
      timerEl.textContent = `‚è±Ô∏è ${mm}:${ss}`;
    }

    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        elapsedSeconds++;
        updateTimerDisplay();
        saveState();
      }, 1000);
    }

    function stopTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function flashDifficulty() {
      if (!gridEl) return;
      gridEl.classList.remove("diff-flash");
      void gridEl.offsetWidth;
      gridEl.classList.add("diff-flash");
    }

    function serializeCandidates(cand) {
      return cand.map(row => row.map(set => Array.from(set)));
    }

    function deserializeCandidates(data) {
      return data.map(row => row.map(arr => new Set(arr)));
    }

    function updateMistakeInfo() {
      if (!mistakeInfoEl) return;
      mistakeInfoEl.textContent = `Hata: ${mistakeCount}/${MAX_MISTAKES}`;
    }

    function saveState() {
      if (!puzzle || !solution || !userGrid || !candidates || !fixedByUser) return;
      const state = {
        puzzle,
        solution,
        userGrid,
        candidates: serializeCandidates(candidates),
        fixedByUser,
        difficulty,
        isDark: document.body.classList.contains("dark"),
        elapsedSeconds,
        mistakeCount
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        console.warn("State kaydedilemedi:", e);
      }
    }

    function loadState() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        newGame(true);
        return;
      }
      try {
        const state = JSON.parse(raw);
        if (!state || !state.puzzle || !state.solution || !state.userGrid) {
          newGame(true);
          return;
        }
        puzzle = state.puzzle;
        solution = state.solution;
        userGrid = state.userGrid;
        candidates = deserializeCandidates(state.candidates || []);
        fixedByUser = state.fixedByUser ||
          Array.from({length: N}, () => Array(N).fill(false));
        difficulty = state.difficulty || "orta";
        elapsedSeconds = state.elapsedSeconds || 0;
        mistakeCount = state.mistakeCount || 0;

        if (state.isDark) {
          document.body.classList.add("dark");
          if (themeToggle) themeToggle.textContent = "‚òÄÔ∏è Light";
        } else {
          document.body.classList.remove("dark");
          if (themeToggle) themeToggle.textContent = "üåô Dark";
        }

        document.querySelectorAll(".diff-btn").forEach(btn => {
          btn.classList.remove("active");
          if (btn.dataset.diff === difficulty) btn.classList.add("active");
        });

        selectedCell = null;
        selectedValue = null;
        hintCells = [];
        hintMain = null;
        updateTimerDisplay();
        updateMistakeInfo();
        renderGrid();
        startTimer();
      } catch (e) {
        console.warn("State okunamadƒ±, yeni oyun:", e);
        newGame(true);
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      gridEl = document.getElementById("sudoku-grid");
      loadingOverlay = document.getElementById("loading-overlay");
      themeToggle = document.getElementById("theme-toggle");
      timerEl = document.getElementById("timer");
      mistakeInfoEl = document.getElementById("mistake-info");

      gridEl.innerHTML = "";
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.row = r;
          cell.dataset.col = c;

          if (c === 2 || c === 5) cell.classList.add("thick-right");
          if (r === 2 || r === 5) cell.classList.add("thick-bottom");

          cell.addEventListener("click", () => onCellClick(r, c));
          gridEl.appendChild(cell);
        }
      }

      const numsRow = document.getElementById("numbers-row");
      numsRow.innerHTML = "";
      for (let i = 1; i <= 9; i++) {
        const btn = document.createElement("button");
        btn.textContent = i;
        btn.className = "number-btn";
        btn.addEventListener("click", () => numberPressed(i));
        numsRow.appendChild(btn);
      }

      document.getElementById("new-game").addEventListener("click", () => {
  const ok = confirm("Yeni oyuna ba≈ülamak istediƒüine emin misin? Mevcut ilerlemen silinecek.");
  if (!ok) return;
  flashDifficulty();
  newGame(false);
});

document.getElementById("show-solution").addEventListener("click", () => {
  const ok = confirm("√á√∂z√ºm√º g√∂stermek istediƒüine emin misin? Bulmaca tamamen doldurulacak.");
  if (!ok) return;
  showSolution();
});

      document.getElementById("check").addEventListener("click", checkSolution);
      document.getElementById("show-solution").addEventListener("click", showSolution);
      document.getElementById("hint").addEventListener("click", giveHint);
      document.getElementById("clear-cell").addEventListener("click", clearCell);

      const noteBtn = document.getElementById("note-mode");
      noteBtn.addEventListener("click", () => {
        noteMode = !noteMode;
        noteBtn.textContent = "Not Modu: " + (noteMode ? "A√ßƒ±k" : "Kapalƒ±");
        if (noteMode) noteBtn.classList.add("btn-note-on");
        else noteBtn.classList.remove("btn-note-on");
      });

      document.querySelectorAll(".diff-btn").forEach(btn => {
        btn.addEventListener("click", () => {
          document.querySelectorAll(".diff-btn").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          difficulty = btn.dataset.diff;
          flashDifficulty();
          newGame(false);
        });
      });

      themeToggle.addEventListener("click", () => {
        document.body.classList.toggle("dark");
        if (document.body.classList.contains("dark")) {
          themeToggle.textContent = "‚òÄÔ∏è Light";
        } else {
          themeToggle.textContent = "üåô Dark";
        }
        saveState();
      });

      loadState();
    });

    function newGame(isInitial) {
      showLoading();
      stopTimer();
      elapsedSeconds = 0;
      mistakeCount = 0;
      updateTimerDisplay();
      updateMistakeInfo();

      setTimeout(() => {
        const { puzzle: p, solution: s } = generatePuzzle(difficulty);
        puzzle = p;
        solution = s;
        userGrid = puzzle.map(row => row.slice());
        candidates = Array.from(
          {length: N},
          () => Array.from({length: N}, () => new Set())
        );
        fixedByUser = Array.from(
          {length: N},
          () => Array(N).fill(false)
        );
        selectedCell = null;
        selectedValue = null;
        hintCells = [];
        hintMain = null;
        renderGrid();
        hideLoading();
        startTimer();
        saveState();
      }, isInitial ? 0 : 80);
    }

    function getCellElement(row, col) {
      return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
    }

    function renderGrid() {
      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        const r = Number(cell.dataset.row);
        const c = Number(cell.dataset.col);
        cell.classList.remove("selected", "hint-area", "hint-main", "same-number");
        // invalid class'i burada silmiyoruz, yanlƒ±≈üsa kƒ±rmƒ±zƒ± kalsƒ±n

        if (selectedCell && selectedCell.row === r && selectedCell.col === c) {
          cell.classList.add("selected");
        }
        if (hintMain && hintMain.row === r && hintMain.col === c) {
          cell.classList.add("hint-main");
        } else if (hintCells.some(pos => pos.row === r && pos.col === c)) {
          cell.classList.add("hint-area");
        }

        cell.innerHTML = "";
        const val = puzzle[r][c];
        const uval = userGrid[r][c];

        let displayVal = 0;

        if (val !== 0) {
          const mv = document.createElement("div");
          mv.className = "main-value given";
          mv.textContent = val;
          displayVal = val;
          cell.appendChild(mv);
        } else if (uval !== 0) {
          const mv = document.createElement("div");
          mv.className = "main-value user";
          mv.textContent = uval;
          displayVal = uval;
          cell.appendChild(mv);
        } else if (candidates && candidates[r][c].size > 0) {
          const notesDiv = document.createElement("div");
          notesDiv.className = "notes";
          for (let d = 1; d <= 9; d++) {
            const span = document.createElement("div");
            span.className = "note";
            if (candidates[r][c].has(d)) span.textContent = d;
            notesDiv.appendChild(span);
          }
          cell.appendChild(notesDiv);
        }

        if (selectedValue && displayVal === selectedValue) {
          cell.classList.add("same-number");
        }
      });
    }

    function onCellClick(r, c) {
      selectedCell = {row: r, col: c};
      const v = puzzle[r][c] || userGrid[r][c] || null;
      selectedValue = v;
      hintCells = [];
      hintMain = null;
      renderGrid();
    }

    function clearCell() {
      if (!selectedCell) return;
      const {row, col} = selectedCell;
      if (puzzle[row][col] !== 0 || fixedByUser[row][col]) return; // verilen veya doƒüru olanƒ± silme

      if (noteMode) {
        candidates[row][col].clear();
      } else {
        userGrid[row][col] = 0;
        const cellEl = getCellElement(row, col);
        if (cellEl) cellEl.classList.remove("invalid");
      }
      hintCells = [];
      hintMain = null;

      const v = puzzle[row][col] || userGrid[row][col] || null;
      selectedValue = v;
      renderGrid();
      saveState();
    }

    function numberPressed(d) {
  if (!selectedCell) return;
  const {row, col} = selectedCell;

  // Ba≈ülangƒ±√ß sayƒ±larƒ± veya daha √∂nce doƒüru doldurulmu≈ü h√ºcreler deƒüi≈ümesin
  if (puzzle[row][col] !== 0 || fixedByUser[row][col]) return;

  if (noteMode) {
    // NOT MODU: sadece notlarla oyna
    if (userGrid[row][col] !== 0) return; // i√ßinde ana sayƒ± varsa not tutma
    if (candidates[row][col].has(d)) {
      candidates[row][col].delete(d);
    } else {
      candidates[row][col].add(d);
    }
  } else {
    // NORMAL MOD: sayƒ± kesin yazƒ±lƒ±yor ‚Üí hemen kontrol et
    const cellEl = getCellElement(row, col);
    let wrong = false;

    if (solution[row][col] === d) {
      // DOƒûRU ‚Üí h√ºcre kilitlenir
      userGrid[row][col] = d;
      candidates[row][col].clear();
      fixedByUser[row][col] = true;
      if (cellEl) cellEl.classList.remove("invalid");
    } else {
      // YANLI≈û ‚Üí kƒ±rmƒ±zƒ±ya boya, hata ekle
      userGrid[row][col] = d;
      candidates[row][col].clear();
      wrong = true;
      if (cellEl) cellEl.classList.add("invalid");
    }

    // Ne olursa olsun: bu sayƒ± satƒ±r/s√ºtun/kutudaki notlardan silinsin
    updateNotesAfterNumber(row, col, d);

    if (wrong) {
      mistakeCount++;
      updateMistakeInfo();

      if (mistakeCount >= MAX_MISTAKES) {
        alert("5 hata yaptƒ±n, oyun ba≈ütan ba≈ülƒ±yor üíó");
        mistakeCount = 0;
        newGame(false);
        return;
      } else {
        alert(`Bu karede ${d} doƒüru deƒüil. Hata sayƒ±n: ${mistakeCount}/${MAX_MISTAKES}`);
      }
    }
  }

  // Aynƒ± sayƒ± vurgusu i√ßin se√ßili deƒüeri g√ºncelle
  const v = puzzle[row][col] || userGrid[row][col] || null;
  selectedValue = v;

  hintCells = [];
  hintMain = null;
  renderGrid();
  saveState();
}


    function checkSolution() {
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          if (userGrid[r][c] !== solution[r][c]) {
            alert("√á√∂z√ºm doƒüru deƒüil, biraz daha dene üôÇ");
            return;
          }
        }
      }
      stopTimer();
      const m = Math.floor(elapsedSeconds / 60);
      const s = elapsedSeconds % 60;
      const mm = String(m).padStart(2, "0");
      const ss = String(s).padStart(2, "0");
      alert(`Tebrikler! Sudokuyu √ß√∂zd√ºn üéâ\nS√ºren: ${mm}:${ss}\nHata sayƒ±n: ${mistakeCount}`);
      saveState();
    }

    function showSolution() {
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          userGrid[r][c] = solution[r][c];
          candidates[r][c].clear();
          fixedByUser[r][c] = true;
          const cellEl = getCellElement(r, c);
          if (cellEl) cellEl.classList.remove("invalid");
        }
      }
      stopTimer();
      hintCells = [];
      hintMain = null;
      renderGrid();
      saveState();
    }

    function computeLogicCandidates() {
      const grid = userGrid.map(row => row.slice());
      const cands = Array.from(
        {length: N},
        () => Array.from({length: N}, () => new Set())
      );
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          if (grid[r][c] === 0) {
            for (let d = 1; d <= 9; d++) {
              if (isValid(grid, r, c, d)) cands[r][c].add(d);
            }
          }
        }
      }
      return cands;
    }

    function notesComment(r, c, d, scopeType) {
      let msg = "";
      const userNotes = candidates[r][c];

      if (userNotes.size > 0) {
        if (userNotes.has(d) && userNotes.size > 1) {
          msg += `\nNotlarƒ±nda ${d} zaten var, diƒüer adaylarƒ±nƒ± azaltmayƒ± d√º≈ü√ºnebilirsin.`;
        } else if (userNotes.has(d) && userNotes.size === 1) {
          msg += `\nNotlarƒ±nla zaten ${d}‚Äôyi se√ßmi≈üsin, artƒ±k bu kareyi doldurabilirsin.`;
        } else if (!userNotes.has(d)) {
          msg += `\nNot tutuyorsan, bu kareye ${d} adayƒ±nƒ± ekleyebilirsin.`;
        }
      } else {
        msg += `\nBu karede hi√ß notun yoksa, ${d}‚Äôyi g√º√ßl√º bir aday olarak d√º≈ü√ºnebilirsin.`;
      }

      if (scopeType === "row") {
        const others = [];
        for (let cc = 0; cc < N; cc++) {
          if (candidates[r][cc].has(d) && cc !== c) others.push([r, cc]);
        }
        if (others.length > 0) {
          msg += `\nBu satƒ±rdaki diƒüer karelere yazdƒ±ƒüƒ±n ${d} notlarƒ±nƒ± silebilirsin.`;
        }
      } else if (scopeType === "col") {
        const others = [];
        for (let rr = 0; rr < N; rr++) {
          if (candidates[rr][c].has(d) && rr !== r) others.push([rr, c]);
        }
        if (others.length > 0) {
          msg += `\nBu s√ºtundaki diƒüer karelerdeki ${d} notlarƒ±nƒ± da temizleyebilirsin.`;
        }
      } else if (scopeType === "box") {
        const br = Math.floor(r / 3) * 3;
        const bc = Math.floor(c / 3) * 3;
        const others = [];
        for (let rr = br; rr < br + 3; rr++) {
          for (let cc = bc; cc < bc + 3; cc++) {
            if (candidates[rr][cc].has(d) && (rr !== r || cc !== c)) {
              others.push([rr, cc]);
            }
          }
        }
        if (others.length > 0) {
          msg += `\nBu kutudaki diƒüer h√ºcrelere yazdƒ±ƒüƒ±n ${d} notlarƒ±nƒ± silebilirsin.`;
        }
      } else if (scopeType === "single") {
        if (userNotes.size > 1 || userNotes.has(d)) {
          msg += `\nBurada sadece ${d} ge√ßerli olduƒüundan, diƒüer t√ºm notlarƒ±nƒ± g√ºvenle silebilirsin.`;
        }
      }

      return msg;
    }

    function giveHint() {
      const cands = computeLogicCandidates();

      for (let r = 0; r < N; r++) {
        for (let d = 1; d <= 9; d++) {
          const cells = [];
          for (let c = 0; c < N; c++) {
            if (cands[r][c].has(d)) cells.push({row: r, col: c});
          }
          if (cells.length === 1) {
            const {row, col} = cells[0];
            hintMain = {row, col};
            hintCells = [];
            for (let cc = 0; cc < N; cc++) hintCells.push({row: r, col: cc});
            selectedCell = {row, col};
            selectedValue = solution[row][col];
            renderGrid();
            const extra = notesComment(row, col, d, "row");
            alert(`${r+1}. satƒ±ra odaklan.\nSayƒ± ${d} bu satƒ±rda sadece se√ßili kareye sƒ±ƒüƒ±yor.` + extra);
            saveState();
            return;
          }
        }
      }

      for (let c = 0; c < N; c++) {
        for (let d = 1; d <= 9; d++) {
          const cells = [];
          for (let r = 0; r < N; r++) {
            if (cands[r][c].has(d)) cells.push({row: r, col: c});
          }
          if (cells.length === 1) {
            const {row, col} = cells[0];
            hintMain = {row, col};
            hintCells = [];
            for (let rr = 0; rr < N; rr++) hintCells.push({row: rr, col: c});
            selectedCell = {row, col};
            selectedValue = solution[row][col];
            renderGrid();
            const extra = notesComment(row, col, d, "col");
            alert(`${c+1}. s√ºtuna bak.\nSayƒ± ${d} bu s√ºtunda sadece se√ßili h√ºcrede m√ºmk√ºn.` + extra);
            saveState();
            return;
          }
        }
      }

      for (let br = 0; br < N; br += 3) {
        for (let bc = 0; bc < N; bc += 3) {
          for (let d = 1; d <= 9; d++) {
            const cells = [];
            for (let r = br; r < br + 3; r++) {
              for (let c = bc; c < bc + 3; c++) {
                if (cands[r][c].has(d)) cells.push({row: r, col: c});
              }
            }
            if (cells.length === 1) {
              const {row, col} = cells[0];
              hintMain = {row, col};
              hintCells = [];
              for (let r = br; r < br + 3; r++) {
                for (let c = bc; c < bc + 3; c++) {
                  hintCells.push({row: r, col: c});
                }
              }
              selectedCell = {row, col};
              selectedValue = solution[row][col];
              renderGrid();
              const extra = notesComment(row, col, d, "box");
              alert(`Se√ßili h√ºcrenin bulunduƒüu 3√ó3 kutuya bak.\nSayƒ± ${d} bu kutuda sadece bu kareye sƒ±ƒüƒ±yor.` + extra);
              saveState();
              return;
            }
          }
        }
      }

      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          if (userGrid[r][c] === 0 && cands[r][c].size === 1) {
            const d = [...cands[r][c]][0];
            hintMain = {row: r, col: c};
            hintCells = [];
            selectedCell = {row: r, col: c};
            selectedValue = d;
            renderGrid();
            const extra = notesComment(r, c, d, "single");
            alert(`Se√ßili kareye bak.\nSudoku kurallarƒ±na g√∂re burada sadece ${d} m√ºmk√ºn.` + extra);
            saveState();
            return;
          }
        }
      }

      alert("Basit mantƒ±kla bulunabilecek yeni bir hamle kalmadƒ±.\nBelki daha ileri teknikler gerekir üôÇ");
    }
  </script>
</body>
</html>
